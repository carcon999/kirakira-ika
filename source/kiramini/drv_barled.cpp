
#include "arduino.h"
#include "drv_barled.h"
#include "i2s.h"    // I2S
#include "math.h"

using namespace kira;

// global instance
kira::Barled LED;

static const uint16_t bitpatterns[16] = {
  0b1000100010001000, 0b1000100010001100, 0b1000100011001000, 0b1000100011001100,
  0b1000110010001000, 0b1000110010001100, 0b1000110011001000, 0b1000110011001100,
  0b1100100010001000, 0b1100100010001100, 0b1100100011001000, 0b1100100011001100,
  0b1100110010001000, 0b1100110010001100, 0b1100110011001000, 0b1100110011001100,
};

#define PROGRESS22_SIZE   (44)
#define PROGRESS32_SIZE   (64)

static const uint32_t progress22[PROGRESS22_SIZE] = {
  0b00000000000000000000000000000001, // 1
  0b00000000000000000000000000000011, // 2
  0b00000000000000000000000000000111, // 3
  0b00000000000000000000000000001111, // 4
  0b00000000000000000000000000011111, // 5
  0b00000000000000000000000000111111, // 6
  0b00000000000000000000000001111111, // 7
  0b00000000000000000000000011111111, // 8
  0b00000000000000000000000111111111, // 9
  0b00000000000000000000001111111111, // 10
  0b00000000000000000000011111111111, // 11
  0b00000000000000000000111111111111, // 12
  0b00000000000000000001111111111111, // 13
  0b00000000000000000011111111111111, // 14
  0b00000000000000000111111111111111, // 15
  0b00000000000000001111111111111111, // 16
  0b00000000000000011111111111111111, // 17
  0b00000000000000111111111111111111, // 18
  0b00000000000001111111111111111111, // 19
  0b00000000000011111111111111111111, // 20
  0b00000000000111111111111111111111, // 21
  0b00000000001111111111111111111111, // 22
  0b00000000001111111111111111111110, // 23
  0b00000000001111111111111111111100, // 24
  0b00000000001111111111111111111000, // 25
  0b00000000001111111111111111110000, // 26
  0b00000000001111111111111111100000, // 27
  0b00000000001111111111111111000000, // 28
  0b00000000001111111111111110000000, // 29
  0b00000000001111111111111100000000, // 30
  0b00000000001111111111111000000000, // 31
  0b00000000001111111111110000000000, // 32
  0b00000000001111111111100000000000, // 33
  0b00000000001111111111000000000000, // 34
  0b00000000001111111110000000000000, // 35
  0b00000000001111111100000000000000, // 36
  0b00000000001111111000000000000000, // 37
  0b00000000001111110000000000000000, // 38
  0b00000000001111100000000000000000, // 39
  0b00000000001111000000000000000000, // 40
  0b00000000001110000000000000000000, // 41
  0b00000000001100000000000000000000, // 42
  0b00000000001000000000000000000000, // 43
  0b00000000000000000000000000000000, // 44
};

static const uint32_t progress32[PROGRESS32_SIZE] = {
  0b00000000000000000000000000000001, // 1
  0b00000000000000000000000000000011, // 2
  0b00000000000000000000000000000111, // 3
  0b00000000000000000000000000001111, // 4
  0b00000000000000000000000000011111, // 5
  0b00000000000000000000000000111111, // 6
  0b00000000000000000000000001111111, // 7
  0b00000000000000000000000011111111, // 8
  0b00000000000000000000000111111111, // 9
  0b00000000000000000000001111111111, // 10
  0b00000000000000000000011111111111, // 11
  0b00000000000000000000111111111111, // 12
  0b00000000000000000001111111111111, // 13
  0b00000000000000000011111111111111, // 14
  0b00000000000000000111111111111111, // 15
  0b00000000000000001111111111111111, // 16
  0b00000000000000011111111111111111, // 17
  0b00000000000000111111111111111111, // 18
  0b00000000000001111111111111111111, // 19
  0b00000000000011111111111111111111, // 20
  0b00000000000111111111111111111111, // 21
  0b00000000001111111111111111111111, // 22
  0b00000000011111111111111111111111, // 23
  0b00000000111111111111111111111111, // 24
  0b00000001111111111111111111111111, // 25
  0b00000011111111111111111111111111, // 26
  0b00000111111111111111111111111111, // 27
  0b00001111111111111111111111111111, // 28
  0b00011111111111111111111111111111, // 29
  0b00111111111111111111111111111111, // 30
  0b01111111111111111111111111111111, // 31
  0b11111111111111111111111111111111, // 32
  0b11111111111111111111111111111110, // 33
  0b11111111111111111111111111111100, // 34
  0b11111111111111111111111111111000, // 35
  0b11111111111111111111111111110000, // 36
  0b11111111111111111111111111100000, // 37
  0b11111111111111111111111111000000, // 38
  0b11111111111111111111111110000000, // 39
  0b11111111111111111111111100000000, // 40
  0b11111111111111111111111000000000, // 41
  0b11111111111111111111110000000000, // 42
  0b11111111111111111111100000000000, // 43
  0b11111111111111111111000000000000, // 44
  0b11111111111111111110000000000000, // 45
  0b11111111111111111100000000000000, // 46
  0b11111111111111111000000000000000, // 47
  0b11111111111111110000000000000000, // 48
  0b11111111111111100000000000000000, // 49
  0b11111111111111000000000000000000, // 50
  0b11111111111110000000000000000000, // 51
  0b11111111111100000000000000000000, // 52
  0b11111111111000000000000000000000, // 53
  0b11111111110000000000000000000000, // 54
  0b11111111100000000000000000000000, // 55
  0b11111111000000000000000000000000, // 56
  0b11111110000000000000000000000000, // 57
  0b11111100000000000000000000000000, // 58
  0b11111000000000000000000000000000, // 59
  0b11110000000000000000000000000000, // 60
  0b11100000000000000000000000000000, // 61
  0b11000000000000000000000000000000, // 62
  0b10000000000000000000000000000000, // 63
  0b00000000000000000000000000000000  // 64
};


// 初期化処理を行う関数
// コンストラクタは　クラス名::クラス名と同じ名前で構成します
Barled::Barled()
{
}

// 通信初期化
void Barled::begin(uint8_t len)
{
  // LED数
  led_count = len;
  
  if(!UART_DEBUG){
    // SK6812 LED
    i2s_begin(led_count * LED_RGB_SIZE * sizeof(uint32_t));
    i2s_set_rate(85000);
    delay(100);
  }
}

// 停止
void Barled::end(void)
{
  if(!UART_DEBUG){
    i2s_end();
  }
}

// LED更新
void Barled::update()
{
  if(!UART_DEBUG){
    i2s_write((uint32_t*)&buff[0][0]);
  }
}

// 配列指定
void Barled::set_color(uint8_t grb[LED_MAX_LENGTH][LED_RGB_SIZE])
{
  for(int i = 0 ; i < led_count ; i++)
  {
    set_color(i, grb[i]);
  }

  update();
}

// 個別色変更
void Barled::set_color(int pos, uint8_t grb[LED_RGB_SIZE])
{
  if(pos < led_count)
  {
    // 青
    buff[pos][0] = bitpatterns[(grb[0] >> 4) & 0x0F];
    buff[pos][0] <<= 16;
    buff[pos][0] |= bitpatterns[grb[0] & 0x0F];
    
    // 緑
    buff[pos][1] = bitpatterns[(grb[1] >> 4) & 0x0F];
    buff[pos][1] <<= 16;
    buff[pos][1] |= bitpatterns[grb[1] & 0x0F];
    
    // 赤
    buff[pos][2] = bitpatterns[(grb[2] >> 4) & 0x0F];
    buff[pos][2] <<= 16;
    buff[pos][2] |= bitpatterns[grb[2] & 0x0F];
  }
}

void Barled::set_color(int hue, uint8_t sat, uint8_t val)
{
  uint8_t bgr[LED_RGB_SIZE];
  hsv_to_rgb(hue, sat, val, bgr);
  set_color(bgr);

  update();
}

// 全色変更
void Barled::set_color(uint8_t grb[LED_RGB_SIZE])
{
  for(int i = 0 ; i < led_count ; i++)
  {
    set_color(i, grb);
  }
  update();
}

// データクリア
void Barled::set_color_clear(void)
{
  uint8_t grb[LED_RGB_SIZE] = {0, 0, 0};
  for(int i = 0 ; i < led_count ; i++)
  {
    set_color(i, grb);
  }
}

// 点灯（段階的）
void Barled::turn_on(uint8_t grb[LED_RGB_SIZE])
{
  for(int i = 0 ; i < led_count ; i++)
  {
    set_color(i, grb);
    update();
    delay(10);
    yield();
  }
}

// 消灯
void Barled::turn_off(void)
{
  uint8_t grb[LED_RGB_SIZE] = {0, 0, 0};

  for(int i = 0 ; i < led_count ; i++)
  {
    set_color(led_count -1 - i, grb);
    update();
    delay(10);
    yield();
  }
}

void Barled::test(void)
{
  // HSV色指定
  for(int i = 0 ; i <359 ; i++)
  {
    set_color(i, 255, 10);
    delay(10);
    yield();
  }
}

// 進捗表示
void Barled::set_progress(uint8_t br, uint8_t n)
{
  uint32_t flag = 0;
  uint8_t grb_1[LED_RGB_SIZE] = {0, br, 0};
  uint8_t grb_0[LED_RGB_SIZE] = {0,  0, 0};

  if(led_count == 22){
    n = n % PROGRESS22_SIZE;
    flag = progress22[n];
    
  }else{
    n = n % PROGRESS32_SIZE;
    flag = progress32[n];
  }


  for(int i = 0 ; i < led_count ; i++)
  {
    if(flag & 0x1){
      set_color(i, grb_1);
    }else{
      set_color(i, grb_0);
    }
    flag >>= 1;
  }
  update(); 
}

void Barled::hsv_to_rgb(int h, int s, int v, uint8_t grb[LED_RGB_SIZE])
{
  float f;
  int i, p, q, t;

  h = 360 - h;
  
  i = (int)floor(h / 60.0f) % 6;
  f = (float)(h / 60.0f) - (float)floor(h / 60.0f);
  p = (int)round(v * (1.0f - (s / 255.0f)));
  q = (int)round(v * (1.0f - (s / 255.0f) * f));
  t = (int)round(v * (1.0f - (s / 255.0f) * (1.0f - f)));
  
  switch(i){
    case 0 : grb[1] = v; grb[2] = t; grb[0] = p; break;
    case 1 : grb[1] = q; grb[2] = v; grb[0] = p; break;
    case 2 : grb[1] = p; grb[2] = v; grb[0] = t; break;
    case 3 : grb[1] = p; grb[2] = q; grb[0] = v; break;
    case 4 : grb[1] = t; grb[2] = p; grb[0] = v; break;
    case 5 : grb[1] = v; grb[2] = p; grb[0] = q; break;
  }
}
